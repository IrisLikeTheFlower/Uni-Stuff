10/10
### Завдання:
написати програму для роботи з AVL деревом

AVL дерево:

Це бінарне дерево пошуку, в якого два піддерева відрізняються в висоті не більше ніж на 1 (1 - якщо ліве вище, -1 - якщо праве вище, 0 - якщо рівні)

(я припущу що не треба пояснювати що таке бінарне дерево пошуку)

Якщо різниця висот двох піддерев - 2, чи -2, то дерево самостійно балансується, з допомогою чотирьох видів поворотів (в мене тільки 2 базові, без двох скомбінованих).

(їх добре проілюстровано на цьому сайті: https://www.programiz.com/dsa/avl-tree )

---

#### Моє виконання:
- AVLTree.h
  - створила структуру вузла з полями інформації, висоти, і вказівників на лівий і правий вузли.
  - створила клас AVL дерева з єдиним полем кореня
  - з приватних (допоміжних) методів створила
    - height - метод, що повертає значення поля висоти вузла і 0, якщо вузла немає
    - balanceFactor - метод, що повертає різницю висот лівого і правого піддерев
    - rightRotate, leftRotate - методи поворотів дерева
      - як на сайті вказаному вище, я поміняла місцями вузли
      - перевизначила висоти вузлів
      - метод повертає новий вузол "кореня"
    - balance - метод, який, використовуючи два попередні, балансує дерево, приймаючи його корінь (вузол може бути просто вузлом, а не коренем дерева)
      - якщо вузла немає, то повертається нульовий вказівник
      - висота дерева визначається як максимальна висота двох піддерев, + 1 (бо враховується ще сам вузол, а не тільки піддерева)
      - потім визначається різниця висот піддерев і якщо вона виходить за межі \[-1,1\], то виконуються повороти, як вказано на сайті вказаному спочатку
      - якщо ніяких поворотів не потрібно було проводити, то повертається просто вузол
    - insert - метод для додавання нових елементів в дерево (рекурсивний), приймає вершину від якої починати вставляти (далі завжди корінь) і саме число, яке треба вставити
      - якщо кореня немає, то нова вершина додається як корінь 
      - якщо дані менші значення в корені, то в лівий вузол присвоюється рекурсивно цей ж метод, але вже з коренем - лівий вузол
      - якщо дані більші значення в корені, то відбувається те ж саме, тільки з правим вузлом
      - в іншому випадку (якщо це число вже додане) то просто повертається вузол
      - в самому кінці всіх рекурсій, якщо попередні return не спрацювали, викликається метод balance і повертається вже збалансоване дерево
    - inorderTraversalHelper - метод, який виводить дані вузлів дерева в порядку зростання чисел
      - спочатку рекурсивно знаходиться самий лівий вузол (найменше значення в дереві) і виводиться його значення
      - потім перевіряється, чи немає нічого справа від нього і рекурсивно викликається цей ж метод для правого піддерева
      - повертаючись від рекурсій назад числа будуть виводитися в зростаючому порядку
    - search - метод пошуку значення в дереві, приймає корінь і значення, яке треба знайти
      - якщо вузла немає, або значення вузла дорівнює шуканому, то повертається цей вузол
      - якщо дані менші даних в корені, то викликається цей ж метод рекурсивно для лівого піддерева, в іншому випадку - для правого
    - minValueNode - метод, який знаходить найменше значення в дереві, викликаючи себе рекурсивно для кожного лівого піддерева
    - remove - метод, який видаляє дані з дерева, приймаючи корінь і дані, які треба видалити
      - якщо кореня немає, то він просто повертається
      - якщо дані менші даних в корені, то цей метод викликається рекурсивно для лівого піддерева
      - якщо дані більші даних в корені, то викликається для правого піддерева
      - в іншому випадку перевіряється чи є хоч одне піддерево (ліве, чи праве) в вузла, якщо хоча б одне з них є nullptr, це означає, що поточний вузол є листком (не має дочірніх вузлів або має лише один), і його можна видалити
        - якщо це так, тимчасовий вузол temp встановлюється на одне з існуючих піддерев, яке існує (якщо є), якщо обидва піддерева не існують (nullptr), то temp встановлюється на поточний вузол
        - якщо temp встановлено на nullptr, це означає, що вузол node не має дочірніх вузлів, у цьому випадку просто встановлюється node на nullptr, щоб видалити його
        - якщо temp вказує на існуюче піддерево, то копіюються дані цього піддерева в поточний вузол node, а потім видаляється temp
      - якщо node має обидва дочірніх вузли, то шукається мінімальний вузол у правому піддереві node (вузол з найменшим значенням, більшим за значення node)
      - після знаходження мінімального вузла копіюються його дані в поточний вузол node
      - після цього викликається рекурсивне видалення вузла з правого піддерева, яке тепер містить дані, скопійовані з мінімального вузла
    - printTree - метод, який виводить, повернуте набік, графічно намальоване AVL дерево
      - спочатку виводиться найправіший елемент з кількістю ' ' * 4 перед ним, рівне висоті, на якій знаходиться максимальне число
      - потім елементи додаються по зменшенню, враховуючи кількість ' ' перед ними
      - для зручності розуміння дерева додала / перед правими елементами і \ перед лівими, + -- перед кожним елементом
    - clearTree - метод для повного очищення дерева
      - якщо вузла немає, то просто повертається
      - викликається рекурсивно цей метод для лівого і правого піддерев
      - видаляється вузол
  - з публічних методів створила:
    - конструктор за замовчуванням, який задає корінь в нульорий вказівник
    - методи insert, remove, search, inorderTraversal, printTree, clear, які викликають свої приватні відповідники, починаючи з кореня дерева
- test.cpp
  - перший тест перевіряє правильність роботи методів додавання і пошуку елементів
  - другий тест перевіряє правильність роботи методів додавання, вилучення і пошуку
  - третій тест перевіряє правильність роботи методів додавання, вилучення і пошуку більшої кількості елементів
  - четвертий тест перевіряє правильність роботи методу виведення по порядку
  - п'ятий тест перевіряє правильність роботи методу очистки дерева
  - шостий тест перевіряє всі методи разом, додаючи, прибираючи і виводячи багато елементів
